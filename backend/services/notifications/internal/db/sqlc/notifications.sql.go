// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: notifications.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createNotification = `-- name: CreateNotification :one
INSERT INTO notifications (
    user_id, 
    notif_type, 
    source_service, 
    source_entity_id, 
    needs_action, 
    acted, 
    payload, 
    created_at, 
    expires_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, NOW(), $8
) RETURNING id, user_id, notif_type, source_service, source_entity_id, seen, needs_action, acted, payload, created_at, expires_at, deleted_at
`

type CreateNotificationParams struct {
	UserID         int64
	NotifType      string
	SourceService  string
	SourceEntityID pgtype.Int8
	NeedsAction    pgtype.Bool
	Acted          pgtype.Bool
	Payload        []byte
	ExpiresAt      pgtype.Timestamptz
}

func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createNotification,
		arg.UserID,
		arg.NotifType,
		arg.SourceService,
		arg.SourceEntityID,
		arg.NeedsAction,
		arg.Acted,
		arg.Payload,
		arg.ExpiresAt,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.NotifType,
		&i.SourceService,
		&i.SourceEntityID,
		&i.Seen,
		&i.NeedsAction,
		&i.Acted,
		&i.Payload,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.DeletedAt,
	)
	return i, err
}

const createNotificationType = `-- name: CreateNotificationType :exec
INSERT INTO notification_types (notif_type, category, default_enabled)
VALUES ($1, $2, $3)
ON CONFLICT (notif_type) DO NOTHING
`

type CreateNotificationTypeParams struct {
	NotifType      string
	Category       pgtype.Text
	DefaultEnabled pgtype.Bool
}

func (q *Queries) CreateNotificationType(ctx context.Context, arg CreateNotificationTypeParams) error {
	_, err := q.db.Exec(ctx, createNotificationType, arg.NotifType, arg.Category, arg.DefaultEnabled)
	return err
}

const deleteNotification = `-- name: DeleteNotification :exec
UPDATE notifications SET deleted_at = NOW() WHERE id = $1 AND user_id = $2
`

type DeleteNotificationParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) DeleteNotification(ctx context.Context, arg DeleteNotificationParams) error {
	_, err := q.db.Exec(ctx, deleteNotification, arg.ID, arg.UserID)
	return err
}

const getNotificationByID = `-- name: GetNotificationByID :one
SELECT id, user_id, notif_type, source_service, source_entity_id, seen, needs_action, acted, payload, created_at, expires_at, deleted_at
FROM notifications
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetNotificationByID(ctx context.Context, id int64) (Notification, error) {
	row := q.db.QueryRow(ctx, getNotificationByID, id)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.NotifType,
		&i.SourceService,
		&i.SourceEntityID,
		&i.Seen,
		&i.NeedsAction,
		&i.Acted,
		&i.Payload,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.DeletedAt,
	)
	return i, err
}

const getNotificationType = `-- name: GetNotificationType :one
SELECT notif_type, category, default_enabled
FROM notification_types
WHERE notif_type = $1
`

func (q *Queries) GetNotificationType(ctx context.Context, notifType string) (NotificationType, error) {
	row := q.db.QueryRow(ctx, getNotificationType, notifType)
	var i NotificationType
	err := row.Scan(&i.NotifType, &i.Category, &i.DefaultEnabled)
	return i, err
}

const getUserNotifications = `-- name: GetUserNotifications :many
SELECT id, user_id, notif_type, source_service, source_entity_id, seen, needs_action, acted, payload, created_at, expires_at, deleted_at
FROM notifications
WHERE user_id = $1 
  AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetUserNotificationsParams struct {
	UserID int64
	Limit  int32
	Offset int32
}

func (q *Queries) GetUserNotifications(ctx context.Context, arg GetUserNotificationsParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getUserNotifications, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Notification{}
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.NotifType,
			&i.SourceService,
			&i.SourceEntityID,
			&i.Seen,
			&i.NeedsAction,
			&i.Acted,
			&i.Payload,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserNotificationsCount = `-- name: GetUserNotificationsCount :one
SELECT COUNT(*) 
FROM notifications
WHERE user_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetUserNotificationsCount(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getUserNotificationsCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserUnreadNotificationsCount = `-- name: GetUserUnreadNotificationsCount :one
SELECT COUNT(*) 
FROM notifications
WHERE user_id = $1 AND seen = false AND deleted_at IS NULL
`

func (q *Queries) GetUserUnreadNotificationsCount(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getUserUnreadNotificationsCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const markAllAsRead = `-- name: MarkAllAsRead :exec
UPDATE notifications SET seen = true WHERE user_id = $1 AND seen = false
`

func (q *Queries) MarkAllAsRead(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, markAllAsRead, userID)
	return err
}

const markNotificationAsRead = `-- name: MarkNotificationAsRead :exec
UPDATE notifications SET seen = true WHERE id = $1 AND user_id = $2
`

type MarkNotificationAsReadParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) MarkNotificationAsRead(ctx context.Context, arg MarkNotificationAsReadParams) error {
	_, err := q.db.Exec(ctx, markNotificationAsRead, arg.ID, arg.UserID)
	return err
}
