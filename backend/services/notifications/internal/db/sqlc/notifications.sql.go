// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: notifications.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createNotification = `-- name: CreateNotification :one

INSERT INTO notifications (
    user_id,
    notif_type,
    source_service,
    source_entity_id,
    payload
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING
    id,
    user_id,
    notif_type,
    source_service,
    source_entity_id,
    seen,
    needs_action,
    acted,
    payload,
    created_at,
    expires_at
`

type CreateNotificationParams struct {
	Column1 pgtype.Int8 `json:"column1"`
	Column2 pgtype.Text `json:"column2"`
	Column3 pgtype.Text `json:"column3"`
	Column4 pgtype.Int8 `json:"column4"`
	Column5 []byte      `json:"column5"`
}

type CreateNotificationRow struct {
	ID             int64              `json:"id"`
	UserID         int64              `json:"userId"`
	NotifType      string             `json:"notifType"`
	SourceService  string             `json:"sourceService"`
	SourceEntityID pgtype.Int8        `json:"sourceEntityId"`
	Seen           pgtype.Bool        `json:"seen"`
	NeedsAction    pgtype.Bool        `json:"needsAction"`
	Acted          pgtype.Bool        `json:"acted"`
	Payload        []byte             `json:"payload"`
	CreatedAt      pgtype.Timestamptz `json:"createdAt"`
	ExpiresAt      pgtype.Timestamptz `json:"expiresAt"`
}

// 1: user_id
// 2: notification_ids
func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) (CreateNotificationRow, error) {
	row := q.db.QueryRow(ctx, createNotification,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	var i CreateNotificationRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.NotifType,
		&i.SourceService,
		&i.SourceEntityID,
		&i.Seen,
		&i.NeedsAction,
		&i.Acted,
		&i.Payload,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getNotificationCountAll = `-- name: GetNotificationCountAll :one

SELECT COUNT(*)
FROM notifications
WHERE user_id = $1
    AND deleted_at IS NULL
`

// 1: user_id
// 2: seen
// 3: limit
// 4: offset
func (q *Queries) GetNotificationCountAll(ctx context.Context, dollar_1 pgtype.Int8) (pgtype.Int8, error) {
	row := q.db.QueryRow(ctx, getNotificationCountAll, dollar_1)
	var count pgtype.Int8
	err := row.Scan(&count)
	return count, err
}

const getNotificationCountFilteredByStatus = `-- name: GetNotificationCountFilteredByStatus :one

SELECT COUNT(*)
FROM notifications
WHERE user_id = $1
    AND seen = $2
    AND deleted_at IS NULL
`

type GetNotificationCountFilteredByStatusParams struct {
	Column1 pgtype.Int8 `json:"column1"`
	Column2 pgtype.Bool `json:"column2"`
}

// 1: user_id
func (q *Queries) GetNotificationCountFilteredByStatus(ctx context.Context, arg GetNotificationCountFilteredByStatusParams) (pgtype.Int8, error) {
	row := q.db.QueryRow(ctx, getNotificationCountFilteredByStatus, arg.Column1, arg.Column2)
	var count pgtype.Int8
	err := row.Scan(&count)
	return count, err
}

const getNotificationsByUserIdAll = `-- name: GetNotificationsByUserIdAll :many
SELECT
    id,
    user_id,
    notif_type,
    source_service,
    source_entity_id,
    seen,
    needs_action,
    acted,
    payload,
    created_at,
    expires_at
FROM notifications
WHERE user_id = $1
    AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type GetNotificationsByUserIdAllParams struct {
	Column1 pgtype.Int8 `json:"column1"`
	Column2 pgtype.Int8 `json:"column2"`
	Column3 pgtype.Int8 `json:"column3"`
}

type GetNotificationsByUserIdAllRow struct {
	ID             int64              `json:"id"`
	UserID         int64              `json:"userId"`
	NotifType      string             `json:"notifType"`
	SourceService  string             `json:"sourceService"`
	SourceEntityID pgtype.Int8        `json:"sourceEntityId"`
	Seen           pgtype.Bool        `json:"seen"`
	NeedsAction    pgtype.Bool        `json:"needsAction"`
	Acted          pgtype.Bool        `json:"acted"`
	Payload        []byte             `json:"payload"`
	CreatedAt      pgtype.Timestamptz `json:"createdAt"`
	ExpiresAt      pgtype.Timestamptz `json:"expiresAt"`
}

func (q *Queries) GetNotificationsByUserIdAll(ctx context.Context, arg GetNotificationsByUserIdAllParams) ([]GetNotificationsByUserIdAllRow, error) {
	rows, err := q.db.Query(ctx, getNotificationsByUserIdAll, arg.Column1, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNotificationsByUserIdAllRow{}
	for rows.Next() {
		var i GetNotificationsByUserIdAllRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.NotifType,
			&i.SourceService,
			&i.SourceEntityID,
			&i.Seen,
			&i.NeedsAction,
			&i.Acted,
			&i.Payload,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotificationsByUserIdFilteredByStatus = `-- name: GetNotificationsByUserIdFilteredByStatus :many

SELECT
    id,
    user_id,
    notif_type,
    source_service,
    source_entity_id,
    seen,
    needs_action,
    acted,
    payload,
    created_at,
    expires_at
FROM notifications
WHERE user_id = $1
    AND seen = $2
    AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $3
OFFSET $4
`

type GetNotificationsByUserIdFilteredByStatusParams struct {
	Column1 pgtype.Int8 `json:"column1"`
	Column2 pgtype.Bool `json:"column2"`
	Column3 pgtype.Int8 `json:"column3"`
	Column4 pgtype.Int8 `json:"column4"`
}

type GetNotificationsByUserIdFilteredByStatusRow struct {
	ID             int64              `json:"id"`
	UserID         int64              `json:"userId"`
	NotifType      string             `json:"notifType"`
	SourceService  string             `json:"sourceService"`
	SourceEntityID pgtype.Int8        `json:"sourceEntityId"`
	Seen           pgtype.Bool        `json:"seen"`
	NeedsAction    pgtype.Bool        `json:"needsAction"`
	Acted          pgtype.Bool        `json:"acted"`
	Payload        []byte             `json:"payload"`
	CreatedAt      pgtype.Timestamptz `json:"createdAt"`
	ExpiresAt      pgtype.Timestamptz `json:"expiresAt"`
}

// 1: user_id
// 2: limit
// 3: offset
func (q *Queries) GetNotificationsByUserIdFilteredByStatus(ctx context.Context, arg GetNotificationsByUserIdFilteredByStatusParams) ([]GetNotificationsByUserIdFilteredByStatusRow, error) {
	rows, err := q.db.Query(ctx, getNotificationsByUserIdFilteredByStatus,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNotificationsByUserIdFilteredByStatusRow{}
	for rows.Next() {
		var i GetNotificationsByUserIdFilteredByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.NotifType,
			&i.SourceService,
			&i.SourceEntityID,
			&i.Seen,
			&i.NeedsAction,
			&i.Acted,
			&i.Payload,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markNotificationAsActed = `-- name: MarkNotificationAsActed :exec

UPDATE notifications
SET acted = true
WHERE id = $1
    AND deleted_at IS NULL
`

// 1: user_id
// 2: notif_type
// 3: source_service
// 4: source_entity_id
// 5: payload
func (q *Queries) MarkNotificationAsActed(ctx context.Context, dollar_1 pgtype.Int8) error {
	_, err := q.db.Exec(ctx, markNotificationAsActed, dollar_1)
	return err
}

const markNotificationsAsRead = `-- name: MarkNotificationsAsRead :exec

UPDATE notifications
SET seen = true
WHERE user_id = $1
    AND id = ANY($2::bigint[])
    AND seen = false
    AND deleted_at IS NULL
`

type MarkNotificationsAsReadParams struct {
	Column1 pgtype.Int8 `json:"column1"`
	Column2 []int64     `json:"column2"`
}

// 1: user_id
// 2: seen
func (q *Queries) MarkNotificationsAsRead(ctx context.Context, arg MarkNotificationsAsReadParams) error {
	_, err := q.db.Exec(ctx, markNotificationsAsRead, arg.Column1, arg.Column2)
	return err
}
