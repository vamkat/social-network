// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: posts.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clearPostAudience = `-- name: ClearPostAudience :exec
DELETE FROM post_audience
WHERE post_id = $1
`

func (q *Queries) ClearPostAudience(ctx context.Context, postID int64) error {
	_, err := q.db.Exec(ctx, clearPostAudience, postID)
	return err
}

const createPost = `-- name: CreatePost :one
INSERT INTO posts (post_body, creator_id, group_id, audience)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreatePostParams struct {
	PostBody  string
	CreatorID int64
	GroupID   pgtype.Int8
	Audience  IntendedAudience
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (int64, error) {
	row := q.db.QueryRow(ctx, createPost,
		arg.PostBody,
		arg.CreatorID,
		arg.GroupID,
		arg.Audience,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deletePost = `-- name: DeletePost :execrows
UPDATE posts
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND creator_id=$2 AND deleted_at IS NULL
`

type DeletePostParams struct {
	ID        int64
	CreatorID int64
}

func (q *Queries) DeletePost(ctx context.Context, arg DeletePostParams) (int64, error) {
	result, err := q.db.Exec(ctx, deletePost, arg.ID, arg.CreatorID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const editPostContent = `-- name: EditPostContent :execrows
UPDATE posts
SET post_body  = $1
WHERE id = $2 AND creator_id = $3 AND deleted_at IS NULL
`

type EditPostContentParams struct {
	PostBody  string
	ID        int64
	CreatorID int64
}

func (q *Queries) EditPostContent(ctx context.Context, arg EditPostContentParams) (int64, error) {
	result, err := q.db.Exec(ctx, editPostContent, arg.PostBody, arg.ID, arg.CreatorID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getGroupPostsPaginated = `-- name: GetGroupPostsPaginated :many
SELECT
    p.id,
    p.post_body,
    p.creator_id,
    p.group_id,
    p.audience,
    p.comments_count,
    p.reactions_count,
    p.last_commented_at,
    p.created_at,
    p.updated_at,

    EXISTS (     -- Has the given user liked the post?
        SELECT 1
        FROM reactions r
        WHERE r.content_id = p.id
          AND r.user_id = $2              -- requesting user (check is member from users service)
          AND r.deleted_at IS NULL
    ) AS liked_by_user,
   
    (SELECT i.id    
     FROM images i
     WHERE i.parent_id = p.id
       AND i.deleted_at IS NULL
     ORDER BY i.sort_order
     LIMIT 1
    ) AS image,

     -- latest comment using LATERAL join
    lc.id AS latest_comment_id,
    lc.comment_creator_id AS latest_comment_creator_id,
    lc.comment_body AS latest_comment_body,
    lc.reactions_count AS latest_comment_reactions_count,
    lc.created_at AS latest_comment_created_at,
    lc.updated_at AS latest_comment_updated_at,
    lc.liked_by_user AS latest_comment_liked_by_user,
    lc.image AS latest_comment_image


FROM posts p

LEFT JOIN LATERAL (
    SELECT
        c.id,
        c.comment_creator_id,
        c.comment_body,
        c.reactions_count,
        c.created_at,
        c.updated_at,
        EXISTS (
            SELECT 1 FROM reactions r
            WHERE r.content_id = c.id
              AND r.user_id = $2
              AND r.deleted_at IS NULL
        ) AS liked_by_user,
        (
            SELECT i.id
            FROM images i
            WHERE i.parent_id = c.id
              AND i.deleted_at IS NULL
            ORDER BY i.sort_order
            LIMIT 1
        ) AS image
    FROM comments c
    WHERE c.parent_id = p.id
      AND c.deleted_at IS NULL
    ORDER BY c.created_at DESC
    LIMIT 1
) lc ON TRUE


WHERE p.group_id = $1                    -- group id filter
  AND p.deleted_at IS NULL
GROUP BY p.id
ORDER BY p.created_at DESC               -- newest first
LIMIT $3 OFFSET $4
`

type GetGroupPostsPaginatedParams struct {
	GroupID pgtype.Int8
	UserID  int64
	Limit   int32
	Offset  int32
}

type GetGroupPostsPaginatedRow struct {
	ID                          int64
	PostBody                    string
	CreatorID                   int64
	GroupID                     pgtype.Int8
	Audience                    IntendedAudience
	CommentsCount               int32
	ReactionsCount              int32
	LastCommentedAt             pgtype.Timestamptz
	CreatedAt                   pgtype.Timestamptz
	UpdatedAt                   pgtype.Timestamptz
	LikedByUser                 bool
	Image                       int64
	LatestCommentID             int64
	LatestCommentCreatorID      int64
	LatestCommentBody           string
	LatestCommentReactionsCount int32
	LatestCommentCreatedAt      pgtype.Timestamptz
	LatestCommentUpdatedAt      pgtype.Timestamptz
	LatestCommentLikedByUser    bool
	LatestCommentImage          int64
}

func (q *Queries) GetGroupPostsPaginated(ctx context.Context, arg GetGroupPostsPaginatedParams) ([]GetGroupPostsPaginatedRow, error) {
	rows, err := q.db.Query(ctx, getGroupPostsPaginated,
		arg.GroupID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGroupPostsPaginatedRow{}
	for rows.Next() {
		var i GetGroupPostsPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.PostBody,
			&i.CreatorID,
			&i.GroupID,
			&i.Audience,
			&i.CommentsCount,
			&i.ReactionsCount,
			&i.LastCommentedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LikedByUser,
			&i.Image,
			&i.LatestCommentID,
			&i.LatestCommentCreatorID,
			&i.LatestCommentBody,
			&i.LatestCommentReactionsCount,
			&i.LatestCommentCreatedAt,
			&i.LatestCommentUpdatedAt,
			&i.LatestCommentLikedByUser,
			&i.LatestCommentImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostPopularPostInGroup = `-- name: GetMostPopularPostInGroup :one
SELECT
    p.id,
    p.post_body,
    p.creator_id,
    p.group_id,
    p.audience,
    p.comments_count,
    p.reactions_count,
    p.last_commented_at,
    p.created_at,
    p.updated_at,

    (SELECT i.id    
     FROM images i
     WHERE i.parent_id = p.id
       AND i.deleted_at IS NULL
     ORDER BY i.sort_order
     LIMIT 1
    ) AS image,


    (p.reactions_count + p.comments_count) AS popularity_score     -- popularity metric (likes + comments)

FROM posts p
WHERE p.group_id = $1
  AND p.deleted_at IS NULL

ORDER BY popularity_score DESC, p.created_at DESC
LIMIT 1
`

type GetMostPopularPostInGroupRow struct {
	ID              int64
	PostBody        string
	CreatorID       int64
	GroupID         pgtype.Int8
	Audience        IntendedAudience
	CommentsCount   int32
	ReactionsCount  int32
	LastCommentedAt pgtype.Timestamptz
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	Image           int64
	PopularityScore int32
}

func (q *Queries) GetMostPopularPostInGroup(ctx context.Context, groupID pgtype.Int8) (GetMostPopularPostInGroupRow, error) {
	row := q.db.QueryRow(ctx, getMostPopularPostInGroup, groupID)
	var i GetMostPopularPostInGroupRow
	err := row.Scan(
		&i.ID,
		&i.PostBody,
		&i.CreatorID,
		&i.GroupID,
		&i.Audience,
		&i.CommentsCount,
		&i.ReactionsCount,
		&i.LastCommentedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Image,
		&i.PopularityScore,
	)
	return i, err
}

const getPostAudience = `-- name: GetPostAudience :many
SELECT allowed_user_id
FROM post_audience
WHERE post_id = $1
ORDER BY allowed_user_id
`

func (q *Queries) GetPostAudience(ctx context.Context, postID int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, getPostAudience, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var allowed_user_id int64
		if err := rows.Scan(&allowed_user_id); err != nil {
			return nil, err
		}
		items = append(items, allowed_user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPostsPaginated = `-- name: GetUserPostsPaginated :many

SELECT
    p.id,
    p.post_body,
    p.creator_id,
    p.comments_count,
    p.reactions_count,
    p.last_commented_at,
    p.created_at,
    p.updated_at,

    EXISTS (    -- Has the requesting user liked the post?
        SELECT 1 FROM reactions r
        WHERE r.content_id = p.id
          AND r.user_id = $2
          AND r.deleted_at IS NULL
    ) AS liked_by_user,

    (SELECT i.id     
     FROM images i
     WHERE i.parent_id = p.id
       AND i.deleted_at IS NULL
     ORDER BY i.sort_order
     LIMIT 1
    ) AS image,

     -- latest comment using LATERAL join
    lc.id AS latest_comment_id,
    lc.comment_creator_id AS latest_comment_creator_id,
    lc.comment_body AS latest_comment_body,
    lc.reactions_count AS latest_comment_reactions_count,
    lc.created_at AS latest_comment_created_at,
    lc.updated_at AS latest_comment_updated_at,
    lc.liked_by_user AS latest_comment_liked_by_user,
    lc.image AS latest_comment_image

FROM posts p

LEFT JOIN LATERAL (
    SELECT
        c.id,
        c.comment_creator_id,
        c.comment_body,
        c.reactions_count,
        c.created_at,
        c.updated_at,
        EXISTS (
            SELECT 1 FROM reactions r
            WHERE r.content_id = c.id
              AND r.user_id = $2
              AND r.deleted_at IS NULL
        ) AS liked_by_user,
        (
            SELECT i.id
            FROM images i
            WHERE i.parent_id = c.id
              AND i.deleted_at IS NULL
            ORDER BY i.sort_order
            LIMIT 1
        ) AS image
    FROM comments c
    WHERE c.parent_id = p.id
      AND c.deleted_at IS NULL
    ORDER BY c.created_at DESC
    LIMIT 1
) lc ON TRUE

WHERE p.creator_id = $1                      -- target user we are viewing
  AND p.group_id IS NULL                     -- exclude group posts
  AND p.deleted_at IS NULL

  AND (                    
        p.creator_id = $2    -- If viewer *is* the creator â€” show all posts                
        OR p.audience = 'everyone' -- followers must be checked in users service
        OR (
            p.audience = 'selected'            -- must be specifically allowed
            AND EXISTS (
                SELECT 1
                FROM post_audience pa
                WHERE pa.post_id = p.id
                  AND pa.allowed_user_id = $2
            )
        )
         OR (
            p.audience = 'followers'
            AND p.creator_id = ANY($3::bigint[])          -- viewer follows creator
        )
     )

GROUP BY p.id
ORDER BY p.created_at DESC
LIMIT $4 OFFSET $5
`

type GetUserPostsPaginatedParams struct {
	CreatorID int64
	UserID    int64
	Column3   []int64
	Limit     int32
	Offset    int32
}

type GetUserPostsPaginatedRow struct {
	ID                          int64
	PostBody                    string
	CreatorID                   int64
	CommentsCount               int32
	ReactionsCount              int32
	LastCommentedAt             pgtype.Timestamptz
	CreatedAt                   pgtype.Timestamptz
	UpdatedAt                   pgtype.Timestamptz
	LikedByUser                 bool
	Image                       int64
	LatestCommentID             int64
	LatestCommentCreatorID      int64
	LatestCommentBody           string
	LatestCommentReactionsCount int32
	LatestCommentCreatedAt      pgtype.Timestamptz
	LatestCommentUpdatedAt      pgtype.Timestamptz
	LatestCommentLikedByUser    bool
	LatestCommentImage          int64
}

// pagination
func (q *Queries) GetUserPostsPaginated(ctx context.Context, arg GetUserPostsPaginatedParams) ([]GetUserPostsPaginatedRow, error) {
	rows, err := q.db.Query(ctx, getUserPostsPaginated,
		arg.CreatorID,
		arg.UserID,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserPostsPaginatedRow{}
	for rows.Next() {
		var i GetUserPostsPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.PostBody,
			&i.CreatorID,
			&i.CommentsCount,
			&i.ReactionsCount,
			&i.LastCommentedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LikedByUser,
			&i.Image,
			&i.LatestCommentID,
			&i.LatestCommentCreatorID,
			&i.LatestCommentBody,
			&i.LatestCommentReactionsCount,
			&i.LatestCommentCreatedAt,
			&i.LatestCommentUpdatedAt,
			&i.LatestCommentLikedByUser,
			&i.LatestCommentImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertPostAudience = `-- name: InsertPostAudience :execrows
INSERT INTO post_audience (post_id, allowed_user_id)
SELECT $1::bigint,
       allowed_user_id
FROM unnest($2::bigint[]) AS allowed_user_id
`

type InsertPostAudienceParams struct {
	PostID         int64
	AllowedUserIds []int64
}

func (q *Queries) InsertPostAudience(ctx context.Context, arg InsertPostAudienceParams) (int64, error) {
	result, err := q.db.Exec(ctx, insertPostAudience, arg.PostID, arg.AllowedUserIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updatePostAudience = `-- name: UpdatePostAudience :execrows
UPDATE posts
SET audience = $3,
    updated_at = NOW()
WHERE 
    id = $1
    AND creator_id = $2
    AND deleted_at IS NULL
    AND (audience IS DISTINCT FROM $3)
`

type UpdatePostAudienceParams struct {
	ID        int64
	CreatorID int64
	Audience  IntendedAudience
}

func (q *Queries) UpdatePostAudience(ctx context.Context, arg UpdatePostAudienceParams) (int64, error) {
	result, err := q.db.Exec(ctx, updatePostAudience, arg.ID, arg.CreatorID, arg.Audience)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
