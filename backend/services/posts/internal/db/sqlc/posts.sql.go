// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: posts.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clearPostAudience = `-- name: ClearPostAudience :exec
DELETE FROM post_audience
WHERE post_id = $1
`

func (q *Queries) ClearPostAudience(ctx context.Context, postID int64) error {
	_, err := q.db.Exec(ctx, clearPostAudience, postID)
	return err
}

const createPost = `-- name: CreatePost :one
INSERT INTO posts (post_body, creator_id, group_id, audience)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreatePostParams struct {
	PostBody  string
	CreatorID int64
	GroupID   pgtype.Int8
	Audience  IntendedAudience
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (int64, error) {
	row := q.db.QueryRow(ctx, createPost,
		arg.PostBody,
		arg.CreatorID,
		arg.GroupID,
		arg.Audience,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deletePost = `-- name: DeletePost :exec
UPDATE posts
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeletePost(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deletePost, id)
	return err
}

const editPostContent = `-- name: EditPostContent :one
UPDATE posts
SET post_body  = $1
WHERE id = $2 AND deleted_at IS NULL
RETURNING id, post_body, creator_id, group_id, audience, comments_count, reactions_count, images_count, last_commented_at, created_at, updated_at, deleted_at
`

type EditPostContentParams struct {
	PostBody string
	ID       int64
}

func (q *Queries) EditPostContent(ctx context.Context, arg EditPostContentParams) (Post, error) {
	row := q.db.QueryRow(ctx, editPostContent, arg.PostBody, arg.ID)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.PostBody,
		&i.CreatorID,
		&i.GroupID,
		&i.Audience,
		&i.CommentsCount,
		&i.ReactionsCount,
		&i.ImagesCount,
		&i.LastCommentedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getGroupPostsPaginated = `-- name: GetGroupPostsPaginated :many
SELECT
    p.id,
    p.post_body,
    p.creator_id,
    p.group_id,
    p.audience,
    p.comments_count,
    p.reactions_count,
    p.images_count,
    p.last_commented_at,
    p.created_at,
    p.updated_at,

    EXISTS (     -- Has the given user liked the post?
        SELECT 1
        FROM reactions r
        WHERE r.content_id = p.id
          AND r.user_id = $2              -- requesting user (check is member from users service)
          AND r.deleted_at IS NULL
    ) AS liked_by_user,
   
    (SELECT file_name     -- preview = first image by sort_order
     FROM images i
     WHERE i.entity_id = p.id
       AND i.deleted_at IS NULL
     ORDER BY i.sort_order
     LIMIT 1
    ) AS preview_image

FROM posts p
LEFT JOIN images i ON i.entity_id = p.id AND i.deleted_at IS NULL
WHERE p.group_id = $1                    -- group id filter
  AND p.deleted_at IS NULL
GROUP BY p.id
ORDER BY p.created_at DESC               -- newest first
LIMIT $3 OFFSET $4
`

type GetGroupPostsPaginatedParams struct {
	GroupID pgtype.Int8
	UserID  int64
	Limit   int32
	Offset  int32
}

type GetGroupPostsPaginatedRow struct {
	ID              int64
	PostBody        string
	CreatorID       int64
	GroupID         pgtype.Int8
	Audience        IntendedAudience
	CommentsCount   int32
	ReactionsCount  int32
	ImagesCount     int32
	LastCommentedAt pgtype.Timestamptz
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	LikedByUser     bool
	PreviewImage    pgtype.Text
}

func (q *Queries) GetGroupPostsPaginated(ctx context.Context, arg GetGroupPostsPaginatedParams) ([]GetGroupPostsPaginatedRow, error) {
	rows, err := q.db.Query(ctx, getGroupPostsPaginated,
		arg.GroupID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGroupPostsPaginatedRow{}
	for rows.Next() {
		var i GetGroupPostsPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.PostBody,
			&i.CreatorID,
			&i.GroupID,
			&i.Audience,
			&i.CommentsCount,
			&i.ReactionsCount,
			&i.ImagesCount,
			&i.LastCommentedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LikedByUser,
			&i.PreviewImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostPopularPostInGroup = `-- name: GetMostPopularPostInGroup :one
SELECT
    p.id,
    p.post_body,
    p.creator_id,
    p.group_id,
    p.audience,
    p.comments_count,
    p.reactions_count,
    p.images_count,
    p.last_commented_at,
    p.created_at,
    p.updated_at,

    (SELECT file_name     -- preview image (first by sort_order)
     FROM images i
     WHERE i.entity_id = p.id
       AND i.deleted_at IS NULL
     ORDER BY i.sort_order
     LIMIT 1
    ) AS preview_image,


    (p.reactions_count + p.comments_count) AS popularity_score     -- popularity metric (likes + comments)

FROM posts p
WHERE p.group_id = $1
  AND p.deleted_at IS NULL

ORDER BY popularity_score DESC, p.created_at DESC
LIMIT 1
`

type GetMostPopularPostInGroupRow struct {
	ID              int64
	PostBody        string
	CreatorID       int64
	GroupID         pgtype.Int8
	Audience        IntendedAudience
	CommentsCount   int32
	ReactionsCount  int32
	ImagesCount     int32
	LastCommentedAt pgtype.Timestamptz
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	PreviewImage    string
	PopularityScore int32
}

func (q *Queries) GetMostPopularPostInGroup(ctx context.Context, groupID pgtype.Int8) (GetMostPopularPostInGroupRow, error) {
	row := q.db.QueryRow(ctx, getMostPopularPostInGroup, groupID)
	var i GetMostPopularPostInGroupRow
	err := row.Scan(
		&i.ID,
		&i.PostBody,
		&i.CreatorID,
		&i.GroupID,
		&i.Audience,
		&i.CommentsCount,
		&i.ReactionsCount,
		&i.ImagesCount,
		&i.LastCommentedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PreviewImage,
		&i.PopularityScore,
	)
	return i, err
}

const getPostAudience = `-- name: GetPostAudience :many
SELECT allowed_user_id
FROM post_audience
WHERE post_id = $1
ORDER BY allowed_user_id
`

func (q *Queries) GetPostAudience(ctx context.Context, postID int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, getPostAudience, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var allowed_user_id int64
		if err := rows.Scan(&allowed_user_id); err != nil {
			return nil, err
		}
		items = append(items, allowed_user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostById = `-- name: GetPostById :one
SELECT
    p.id,
    p.post_body,
    p.creator_id,
    p.group_id,
    p.audience,
    p.comments_count,
    p.reactions_count,
    p.images_count,
    p.last_commented_at,
    p.created_at,
    p.updated_at,

    EXISTS (
        SELECT 1
        FROM reactions r
        WHERE r.content_id = p.id
          AND r.user_id = $2
          AND r.deleted_at IS NULL
    ) AS liked_by_user,


    (SELECT file_name     -- preview = first image by sort_order
     FROM images i
     WHERE i.entity_id = p.id
       AND i.deleted_at IS NULL
     ORDER BY i.sort_order
     LIMIT 1
    ) AS preview_image

FROM posts p
WHERE p.id = $1
  AND p.deleted_at IS NULL

  -- VISIBILITY CHECK
  AND (
        p.creator_id = $2
        OR p.audience = 'everyone' --followers must be checked in users service
        OR (
            p.audience = 'selected'
            AND EXISTS (
                SELECT 1 FROM post_audience pa
                WHERE pa.post_id = p.id
                  AND pa.allowed_user_id = $2
            )
        )
      )
`

type GetPostByIdParams struct {
	ID     int64
	UserID int64
}

type GetPostByIdRow struct {
	ID              int64
	PostBody        string
	CreatorID       int64
	GroupID         pgtype.Int8
	Audience        IntendedAudience
	CommentsCount   int32
	ReactionsCount  int32
	ImagesCount     int32
	LastCommentedAt pgtype.Timestamptz
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	LikedByUser     bool
	PreviewImage    string
}

func (q *Queries) GetPostById(ctx context.Context, arg GetPostByIdParams) (GetPostByIdRow, error) {
	row := q.db.QueryRow(ctx, getPostById, arg.ID, arg.UserID)
	var i GetPostByIdRow
	err := row.Scan(
		&i.ID,
		&i.PostBody,
		&i.CreatorID,
		&i.GroupID,
		&i.Audience,
		&i.CommentsCount,
		&i.ReactionsCount,
		&i.ImagesCount,
		&i.LastCommentedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LikedByUser,
		&i.PreviewImage,
	)
	return i, err
}

const getUserPostsPaginated = `-- name: GetUserPostsPaginated :many

SELECT
    p.id,
    p.post_body,
    p.creator_id,
    p.comments_count,
    p.reactions_count,
    p.images_count,
    p.last_commented_at,
    p.created_at,
    p.updated_at,

    EXISTS (    -- Has the requesting user liked the post?
        SELECT 1 FROM reactions r
        WHERE r.content_id = p.id
          AND r.user_id = $2
          AND r.deleted_at IS NULL
    ) AS liked_by_user,

    (SELECT file_name     -- preview = first image by sort_order
     FROM images i
     WHERE i.entity_id = p.id
       AND i.deleted_at IS NULL
     ORDER BY i.sort_order
     LIMIT 1
    ) AS preview_image

FROM posts p
LEFT JOIN images i ON i.entity_id = p.id AND i.deleted_at IS NULL

WHERE p.creator_id = $1                      -- target user we are viewing
  AND p.group_id IS NULL                     -- exclude group posts
  AND p.deleted_at IS NULL

  AND (                    
        p.creator_id = $2    -- If viewer *is* the creator â€” show all posts                
        OR p.audience = 'everyone' -- followers must be checked in users service
        OR (
            p.audience = 'selected'            -- must be specifically allowed
            AND EXISTS (
                SELECT 1
                FROM post_audience pa
                WHERE pa.post_id = p.id
                  AND pa.allowed_user_id = $2
            )
        )
     )

GROUP BY p.id
ORDER BY p.created_at DESC
LIMIT $3 OFFSET $4
`

type GetUserPostsPaginatedParams struct {
	CreatorID int64
	UserID    int64
	Limit     int32
	Offset    int32
}

type GetUserPostsPaginatedRow struct {
	ID              int64
	PostBody        string
	CreatorID       int64
	CommentsCount   int32
	ReactionsCount  int32
	ImagesCount     int32
	LastCommentedAt pgtype.Timestamptz
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	LikedByUser     bool
	PreviewImage    pgtype.Text
}

// pagination
func (q *Queries) GetUserPostsPaginated(ctx context.Context, arg GetUserPostsPaginatedParams) ([]GetUserPostsPaginatedRow, error) {
	rows, err := q.db.Query(ctx, getUserPostsPaginated,
		arg.CreatorID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserPostsPaginatedRow{}
	for rows.Next() {
		var i GetUserPostsPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.PostBody,
			&i.CreatorID,
			&i.CommentsCount,
			&i.ReactionsCount,
			&i.ImagesCount,
			&i.LastCommentedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LikedByUser,
			&i.PreviewImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertPostAudience = `-- name: InsertPostAudience :exec
INSERT INTO post_audience (post_id, allowed_user_id)
SELECT $1, allowed_user_id
FROM unnest($2::bigint[]) AS allowed_user_id
`

type InsertPostAudienceParams struct {
	PostID  int64
	Column2 []int64
}

func (q *Queries) InsertPostAudience(ctx context.Context, arg InsertPostAudienceParams) error {
	_, err := q.db.Exec(ctx, insertPostAudience, arg.PostID, arg.Column2)
	return err
}

const updatePostAudience = `-- name: UpdatePostAudience :exec
UPDATE posts
SET audience = $2, updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

type UpdatePostAudienceParams struct {
	ID       int64
	Audience IntendedAudience
}

func (q *Queries) UpdatePostAudience(ctx context.Context, arg UpdatePostAudienceParams) error {
	_, err := q.db.Exec(ctx, updatePostAudience, arg.ID, arg.Audience)
	return err
}
