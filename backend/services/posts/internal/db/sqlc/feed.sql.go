// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: feed.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getPersonalizedFeed = `-- name: GetPersonalizedFeed :many
SELECT
    p.id,
    p.post_body,
    p.creator_id,
    p.comments_count,
    p.reactions_count,
    p.images_count,
    p.last_commented_at,
    p.created_at,
    p.updated_at,

    -- did user like it?
    EXISTS (
        SELECT 1 FROM reactions r
        WHERE r.content_id = p.id
          AND r.user_id = $1
          AND r.deleted_at IS NULL
    ) AS liked_by_user,

    -- first image preview
    (
      SELECT file_name
      FROM images i
      WHERE i.entity_id = p.id
        AND i.deleted_at IS NULL
      ORDER BY i.sort_order
      LIMIT 1
    ) AS preview_image

FROM posts p
WHERE p.deleted_at IS NULL
  AND (
       -- SELECTED audience → only manually approved viewers
       (p.audience = 'selected' AND EXISTS (
           SELECT 1 FROM post_audience pa
           WHERE pa.post_id = p.id AND pa.allowed_user_id = $1
       ))

       -- FOLLOWERS → allowed if creator ∈ list passed in
       OR (p.audience = 'followers' AND p.creator_id = ANY($2))
  )
ORDER BY p.created_at DESC
OFFSET $3 LIMIT $4
`

type GetPersonalizedFeedParams struct {
	UserID    int64
	CreatorID int64
	Offset    int32
	Limit     int32
}

type GetPersonalizedFeedRow struct {
	ID              int64
	PostBody        string
	CreatorID       int64
	CommentsCount   int32
	ReactionsCount  int32
	ImagesCount     int32
	LastCommentedAt pgtype.Timestamptz
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	LikedByUser     bool
	PreviewImage    string
}

func (q *Queries) GetPersonalizedFeed(ctx context.Context, arg GetPersonalizedFeedParams) ([]GetPersonalizedFeedRow, error) {
	rows, err := q.db.Query(ctx, getPersonalizedFeed,
		arg.UserID,
		arg.CreatorID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPersonalizedFeedRow{}
	for rows.Next() {
		var i GetPersonalizedFeedRow
		if err := rows.Scan(
			&i.ID,
			&i.PostBody,
			&i.CreatorID,
			&i.CommentsCount,
			&i.ReactionsCount,
			&i.ImagesCount,
			&i.LastCommentedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LikedByUser,
			&i.PreviewImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicFeed = `-- name: GetPublicFeed :many
SELECT
    p.id,
    p.post_body,
    p.creator_id,
    p.comments_count,
    p.reactions_count,
    p.last_commented_at,
    p.images_count,
    p.created_at,
    p.updated_at,

    EXISTS (
        SELECT 1 FROM reactions r
        WHERE r.content_id = p.id
          AND r.user_id = $1
          AND r.deleted_at IS NULL
    ) AS liked_by_user,

    (SELECT file_name
     FROM images i
     WHERE i.entity_id = p.id AND i.deleted_at IS NULL
     ORDER BY i.sort_order ASC
     LIMIT 1
    ) AS preview_image

FROM posts p
WHERE p.deleted_at IS NULL
  AND p.audience = 'everyone'
ORDER BY p.created_at DESC
OFFSET $2 LIMIT $3
`

type GetPublicFeedParams struct {
	UserID int64
	Offset int32
	Limit  int32
}

type GetPublicFeedRow struct {
	ID              int64
	PostBody        string
	CreatorID       int64
	CommentsCount   int32
	ReactionsCount  int32
	LastCommentedAt pgtype.Timestamptz
	ImagesCount     int32
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	LikedByUser     bool
	PreviewImage    string
}

func (q *Queries) GetPublicFeed(ctx context.Context, arg GetPublicFeedParams) ([]GetPublicFeedRow, error) {
	rows, err := q.db.Query(ctx, getPublicFeed, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublicFeedRow{}
	for rows.Next() {
		var i GetPublicFeedRow
		if err := rows.Scan(
			&i.ID,
			&i.PostBody,
			&i.CreatorID,
			&i.CommentsCount,
			&i.ReactionsCount,
			&i.LastCommentedAt,
			&i.ImagesCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LikedByUser,
			&i.PreviewImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
