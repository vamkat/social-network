// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: feed.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getPersonalizedFeed = `-- name: GetPersonalizedFeed :many
SELECT
    p.id,
    p.post_body,
    p.creator_id,
    p.comments_count,
    p.reactions_count,
    p.last_commented_at,
    p.created_at,
    p.updated_at,

    -- did user like it?
    EXISTS (
        SELECT 1 FROM reactions r
        WHERE r.content_id = p.id
          AND r.user_id = $1
          AND r.deleted_at IS NULL
    ) AS liked_by_user,

    -- image
    (
      SELECT i.id
      FROM images i
      WHERE i.parent_id = p.id
        AND i.deleted_at IS NULL
      ORDER BY i.sort_order
      LIMIT 1
    ) AS image,

     -- latest comment using LATERAL join
    lc.id AS latest_comment_id,
    lc.comment_creator_id AS latest_comment_creator_id,
    lc.comment_body AS latest_comment_body,
    lc.reactions_count AS latest_comment_reactions_count,
    lc.created_at AS latest_comment_created_at,
    lc.updated_at AS latest_comment_updated_at,
    lc.liked_by_user AS latest_comment_liked_by_user,
    lc.image AS latest_comment_image

FROM posts p

LEFT JOIN LATERAL (
    SELECT
        c.id,
        c.comment_creator_id,
        c.comment_body,
        c.reactions_count,
        c.created_at,
        c.updated_at,
        EXISTS (
            SELECT 1 FROM reactions r
            WHERE r.content_id = c.id
              AND r.user_id = $1
              AND r.deleted_at IS NULL
        ) AS liked_by_user,
        (
            SELECT i.id
            FROM images i
            WHERE i.parent_id = c.id
              AND i.deleted_at IS NULL
            ORDER BY i.sort_order
            LIMIT 1
        ) AS image
    FROM comments c
    WHERE c.parent_id = p.id
      AND c.deleted_at IS NULL
    ORDER BY c.created_at DESC
    LIMIT 1
) lc ON TRUE


WHERE p.deleted_at IS NULL
  AND (
       -- SELECTED audience → only manually approved viewers
       (p.audience = 'selected' AND EXISTS (
           SELECT 1 FROM post_audience pa
           WHERE pa.post_id = p.id AND pa.allowed_user_id = $1
       ))

       -- FOLLOWERS → allowed if creator ∈ list passed in
       OR (p.audience = 'followers' AND p.creator_id = ANY($2::bigint[]))
  )
ORDER BY p.created_at DESC
OFFSET $3 LIMIT $4
`

type GetPersonalizedFeedParams struct {
	UserID  int64
	Column2 []int64
	Offset  int32
	Limit   int32
}

type GetPersonalizedFeedRow struct {
	ID                          int64
	PostBody                    string
	CreatorID                   int64
	CommentsCount               int32
	ReactionsCount              int32
	LastCommentedAt             pgtype.Timestamptz
	CreatedAt                   pgtype.Timestamptz
	UpdatedAt                   pgtype.Timestamptz
	LikedByUser                 bool
	Image                       int64
	LatestCommentID             int64
	LatestCommentCreatorID      int64
	LatestCommentBody           string
	LatestCommentReactionsCount int32
	LatestCommentCreatedAt      pgtype.Timestamptz
	LatestCommentUpdatedAt      pgtype.Timestamptz
	LatestCommentLikedByUser    bool
	LatestCommentImage          int64
}

func (q *Queries) GetPersonalizedFeed(ctx context.Context, arg GetPersonalizedFeedParams) ([]GetPersonalizedFeedRow, error) {
	rows, err := q.db.Query(ctx, getPersonalizedFeed,
		arg.UserID,
		arg.Column2,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPersonalizedFeedRow{}
	for rows.Next() {
		var i GetPersonalizedFeedRow
		if err := rows.Scan(
			&i.ID,
			&i.PostBody,
			&i.CreatorID,
			&i.CommentsCount,
			&i.ReactionsCount,
			&i.LastCommentedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LikedByUser,
			&i.Image,
			&i.LatestCommentID,
			&i.LatestCommentCreatorID,
			&i.LatestCommentBody,
			&i.LatestCommentReactionsCount,
			&i.LatestCommentCreatedAt,
			&i.LatestCommentUpdatedAt,
			&i.LatestCommentLikedByUser,
			&i.LatestCommentImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicFeed = `-- name: GetPublicFeed :many
SELECT
    p.id,
    p.post_body,
    p.creator_id,
    p.comments_count,
    p.reactions_count,
    p.last_commented_at,
    p.created_at,
    p.updated_at,

    EXISTS (
        SELECT 1 FROM reactions r
        WHERE r.content_id = p.id
          AND r.user_id = $1
          AND r.deleted_at IS NULL
    ) AS liked_by_user,

    (SELECT i.id
     FROM images i
     WHERE i.parent_id = p.id AND i.deleted_at IS NULL
     ORDER BY i.sort_order ASC
     LIMIT 1
    ) AS image,

    -- latest comment using LATERAL join
    lc.id AS latest_comment_id,
    lc.comment_creator_id AS latest_comment_creator_id,
    lc.comment_body AS latest_comment_body,
    lc.reactions_count AS latest_comment_reactions_count,
    lc.created_at AS latest_comment_created_at,
    lc.updated_at AS latest_comment_updated_at,
    lc.liked_by_user AS latest_comment_liked_by_user,
    lc.image AS latest_comment_image

FROM posts p

LEFT JOIN LATERAL (
    SELECT
        c.id,
        c.comment_creator_id,
        c.comment_body,
        c.reactions_count,
        c.created_at,
        c.updated_at,
        EXISTS (
            SELECT 1 FROM reactions r
            WHERE r.content_id = c.id
              AND r.user_id = $1
              AND r.deleted_at IS NULL
        ) AS liked_by_user,
        (
            SELECT i.id
            FROM images i
            WHERE i.parent_id = c.id
              AND i.deleted_at IS NULL
            ORDER BY i.sort_order
            LIMIT 1
        ) AS image
    FROM comments c
    WHERE c.parent_id = p.id
      AND c.deleted_at IS NULL
    ORDER BY c.created_at DESC
    LIMIT 1
) lc ON TRUE


WHERE p.deleted_at IS NULL
  AND p.audience = 'everyone'
ORDER BY p.created_at DESC
OFFSET $2 LIMIT $3
`

type GetPublicFeedParams struct {
	UserID int64
	Offset int32
	Limit  int32
}

type GetPublicFeedRow struct {
	ID                          int64
	PostBody                    string
	CreatorID                   int64
	CommentsCount               int32
	ReactionsCount              int32
	LastCommentedAt             pgtype.Timestamptz
	CreatedAt                   pgtype.Timestamptz
	UpdatedAt                   pgtype.Timestamptz
	LikedByUser                 bool
	Image                       int64
	LatestCommentID             int64
	LatestCommentCreatorID      int64
	LatestCommentBody           string
	LatestCommentReactionsCount int32
	LatestCommentCreatedAt      pgtype.Timestamptz
	LatestCommentUpdatedAt      pgtype.Timestamptz
	LatestCommentLikedByUser    bool
	LatestCommentImage          int64
}

func (q *Queries) GetPublicFeed(ctx context.Context, arg GetPublicFeedParams) ([]GetPublicFeedRow, error) {
	rows, err := q.db.Query(ctx, getPublicFeed, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublicFeedRow{}
	for rows.Next() {
		var i GetPublicFeedRow
		if err := rows.Scan(
			&i.ID,
			&i.PostBody,
			&i.CreatorID,
			&i.CommentsCount,
			&i.ReactionsCount,
			&i.LastCommentedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LikedByUser,
			&i.Image,
			&i.LatestCommentID,
			&i.LatestCommentCreatorID,
			&i.LatestCommentBody,
			&i.LatestCommentReactionsCount,
			&i.LatestCommentCreatedAt,
			&i.LatestCommentUpdatedAt,
			&i.LatestCommentLikedByUser,
			&i.LatestCommentImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
