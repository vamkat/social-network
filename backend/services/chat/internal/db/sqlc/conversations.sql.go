// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: conversations.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createGroupConv = `-- name: CreateGroupConv :one
INSERT INTO conversations (group_id)
VALUES ($1)
RETURNING id
`

func (q *Queries) CreateGroupConv(ctx context.Context, groupID pgtype.Int8) (int64, error) {
	row := q.db.QueryRow(ctx, createGroupConv, groupID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createPrivateConv = `-- name: CreatePrivateConv :one
WITH existing AS (
    SELECT c.id
    FROM conversations c
    JOIN conversation_members cm1 ON cm1.conversation_id = c.id AND cm1.user_id = $1
    JOIN conversation_members cm2 ON cm2.conversation_id = c.id AND cm2.user_id = $2
    WHERE c.group_id IS NULL
)
INSERT INTO conversations (group_id)
SELECT NULL
WHERE NOT EXISTS (SELECT 1 FROM existing)
RETURNING id
`

type CreatePrivateConvParams struct {
	UserID   int64
	UserID_2 int64
}

// Creates a Conversation if and only if a DM between the same 2 users does not exist.
// Returns NULL if a duplicate DM exists (sqlc will error if RETURNING finds no rows).
func (q *Queries) CreatePrivateConv(ctx context.Context, arg CreatePrivateConvParams) (int64, error) {
	row := q.db.QueryRow(ctx, createPrivateConv, arg.UserID, arg.UserID_2)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getUserConversations = `-- name: GetUserConversations :many
SELECT 
    c.id AS conversation_id,
    c.group_id,
    c.created_at,
    c.updated_at,
    cm2.user_id AS member_id
FROM conversations c
JOIN conversation_members cm1
    ON cm1.conversation_id = c.id
    AND cm1.user_id = $1
    AND cm1.deleted_at IS NULL
JOIN conversation_members cm2
    ON cm2.conversation_id = c.id
    AND cm2.user_id <> $1
    AND cm2.deleted_at IS NULL
WHERE c.deleted_at IS NULL
AND (
    ($2 IS NULL AND c.group_id IS NULL)
    OR ($2 IS NOT NULL AND c.group_id = $2)
)
ORDER BY c.updated_at DESC
LIMIT $3 OFFSET $4
`

type GetUserConversationsParams struct {
	UserID  int64
	Column2 interface{}
	Limit   int32
	Offset  int32
}

type GetUserConversationsRow struct {
	ConversationID int64
	GroupID        pgtype.Int8
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	MemberID       int64
}

func (q *Queries) GetUserConversations(ctx context.Context, arg GetUserConversationsParams) ([]GetUserConversationsRow, error) {
	rows, err := q.db.Query(ctx, getUserConversations,
		arg.UserID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserConversationsRow{}
	for rows.Next() {
		var i GetUserConversationsRow
		if err := rows.Scan(
			&i.ConversationID,
			&i.GroupID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MemberID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
