// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: conversations.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createGroupConv = `-- name: CreateGroupConv :one
INSERT INTO conversations (group_id)
VALUES ($1)
RETURNING id
`

func (q *Queries) CreateGroupConv(ctx context.Context, groupID pgtype.Int8) (int64, error) {
	row := q.db.QueryRow(ctx, createGroupConv, groupID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createPrivateConv = `-- name: CreatePrivateConv :one
WITH existing AS (
    SELECT c.id
    FROM conversations c
    JOIN conversation_members cm1 ON cm1.conversation_id = c.id AND cm1.user_id = $1
    JOIN conversation_members cm2 ON cm2.conversation_id = c.id AND cm2.user_id = $2
    WHERE c.group_id IS NULL
)
INSERT INTO conversations (group_id)
SELECT NULL
WHERE NOT EXISTS (SELECT 1 FROM existing)
RETURNING id
`

type CreatePrivateConvParams struct {
	UserID   int64
	UserID_2 int64
}

// Creates a Conversation if and only if a conversation between the same 2 users does not exist.
// Returns NULL if a duplicate DM exists (sqlc will error if RETURNING finds no rows).
func (q *Queries) CreatePrivateConv(ctx context.Context, arg CreatePrivateConvParams) (int64, error) {
	row := q.db.QueryRow(ctx, createPrivateConv, arg.UserID, arg.UserID_2)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteConversationByExactMembers = `-- name: DeleteConversationByExactMembers :one
WITH target_members AS (
    SELECT unnest($1::bigint[]) AS user_id
),
matched_conversation AS (
    SELECT cm.conversation_id
    FROM conversation_members cm
    JOIN target_members tm ON tm.user_id = cm.user_id
    GROUP BY cm.conversation_id
    HAVING 
        -- same count of overlapping members
        COUNT(*) = (SELECT COUNT(*) FROM target_members)
        -- and the conversation has no extra members
        AND COUNT(*) = (
            SELECT COUNT(*) 
            FROM conversation_members cm2 
            WHERE cm2.conversation_id = cm.conversation_id
              AND cm2.deleted_at IS NULL
        )
)
UPDATE conversations c
SET deleted_at = NOW(),
    updated_at = NOW()
WHERE c.id = (SELECT conversation_id FROM matched_conversation)
RETURNING id, group_id, created_at, updated_at, deleted_at
`

// Delete a conversation only if its members exactly match the provided list.
// Returns 0 rows if conversation doesn't exist, members donâ€™t match exactly, conversation has extra or missing members.
func (q *Queries) DeleteConversationByExactMembers(ctx context.Context, memberIds []int64) (Conversation, error) {
	row := q.db.QueryRow(ctx, deleteConversationByExactMembers, memberIds)
	var i Conversation
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserConversations = `-- name: GetUserConversations :many
SELECT 
    c.id AS conversation_id,
    c.group_id,
    c.created_at,
    c.updated_at,
    cm2.user_id AS member_id
FROM conversations c
JOIN conversation_members cm1
    ON cm1.conversation_id = c.id
    AND cm1.user_id = $1
    AND cm1.deleted_at IS NULL
JOIN conversation_members cm2
    ON cm2.conversation_id = c.id
    AND cm2.user_id <> $1
    AND cm2.deleted_at IS NULL
WHERE c.deleted_at IS NULL
AND (
    ($2 IS NULL AND c.group_id IS NULL)
    OR ($2 IS NOT NULL AND c.group_id = $2)
)
ORDER BY c.updated_at DESC
LIMIT $3 OFFSET $4
`

type GetUserConversationsParams struct {
	UserID  int64
	Column2 interface{}
	Limit   int32
	Offset  int32
}

type GetUserConversationsRow struct {
	ConversationID int64
	GroupID        pgtype.Int8
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	MemberID       int64
}

// Get all conversations paginated by user id excluding group conversations.
func (q *Queries) GetUserConversations(ctx context.Context, arg GetUserConversationsParams) ([]GetUserConversationsRow, error) {
	rows, err := q.db.Query(ctx, getUserConversations,
		arg.UserID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserConversationsRow{}
	for rows.Next() {
		var i GetUserConversationsRow
		if err := rows.Scan(
			&i.ConversationID,
			&i.GroupID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MemberID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
