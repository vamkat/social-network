// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: auth.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const banUser = `-- name: BanUser :exec
UPDATE users
SET 
    current_status = 'banned',
    ban_ends_at = $2
WHERE id = $1
`

type BanUserParams struct {
	ID        int64        `json:"id"`
	BanEndsAt sql.NullTime `json:"ban_ends_at"`
}

func (q *Queries) BanUser(ctx context.Context, arg BanUserParams) error {
	_, err := q.db.ExecContext(ctx, banUser, arg.ID, arg.BanEndsAt)
	return err
}

const getUserForLogin = `-- name: GetUserForLogin :one
SELECT
    u.id,
    u.username,
    au.password_hash,
    au.salt
FROM users u
JOIN auth_user au ON au.user_id = u.id
WHERE u.username = $1
  AND u.current_status = 'active'
  AND u.deleted_at IS NULL
`

type GetUserForLoginRow struct {
	ID           int64  `json:"id"`
	Username     string `json:"username"`
	PasswordHash string `json:"password_hash"`
	Salt         string `json:"salt"`
}

func (q *Queries) GetUserForLogin(ctx context.Context, username string) (GetUserForLoginRow, error) {
	row := q.db.QueryRowContext(ctx, getUserForLogin, username)
	var i GetUserForLoginRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.Salt,
	)
	return i, err
}

const incrementFailedLoginAttempts = `-- name: IncrementFailedLoginAttempts :exec
UPDATE auth_user
SET failed_attempts = failed_attempts + 1
WHERE user_id = $1
`

func (q *Queries) IncrementFailedLoginAttempts(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, incrementFailedLoginAttempts, userID)
	return err
}

const insertNewUser = `-- name: InsertNewUser :one
INSERT INTO users (
    username,
    first_name,
    last_name,
    date_of_birth,
    avatar,
    about_me,
    profile_public
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id
`

type InsertNewUserParams struct {
	Username      string         `json:"username"`
	FirstName     string         `json:"first_name"`
	LastName      string         `json:"last_name"`
	DateOfBirth   time.Time      `json:"date_of_birth"`
	Avatar        sql.NullString `json:"avatar"`
	AboutMe       sql.NullString `json:"about_me"`
	ProfilePublic bool           `json:"profile_public"`
}

func (q *Queries) InsertNewUser(ctx context.Context, arg InsertNewUserParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertNewUser,
		arg.Username,
		arg.FirstName,
		arg.LastName,
		arg.DateOfBirth,
		arg.Avatar,
		arg.AboutMe,
		arg.ProfilePublic,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertNewUserAuth = `-- name: InsertNewUserAuth :exec
INSERT INTO auth_user (
    user_id,
    email,
    password_hash,
    salt
) VALUES (
       $1, $2, $3, $4
)
`

type InsertNewUserAuthParams struct {
	UserID       int64  `json:"user_id"`
	Email        string `json:"email"`
	PasswordHash string `json:"password_hash"`
	Salt         string `json:"salt"`
}

func (q *Queries) InsertNewUserAuth(ctx context.Context, arg InsertNewUserAuthParams) error {
	_, err := q.db.ExecContext(ctx, insertNewUserAuth,
		arg.UserID,
		arg.Email,
		arg.PasswordHash,
		arg.Salt,
	)
	return err
}

const resetFailedLoginAttempts = `-- name: ResetFailedLoginAttempts :exec
UPDATE auth_user
SET failed_attempts = 0,
    last_login_at = CURRENT_TIMESTAMP
WHERE user_id = $1
`

func (q *Queries) ResetFailedLoginAttempts(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, resetFailedLoginAttempts, userID)
	return err
}

const softDeleteUser = `-- name: SoftDeleteUser :exec
UPDATE users
SET
    current_status = 'deleted',
    deleted_at = CURRENT_TIMESTAMP
WHERE id = $1
  AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, softDeleteUser, id)
	return err
}

const unbanUser = `-- name: UnbanUser :exec
UPDATE users
SET 
    current_status = 'active',
    ban_ends_at = NULL
WHERE id = $1
`

func (q *Queries) UnbanUser(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, unbanUser, id)
	return err
}
